\documentclass{article}
\usepackage[left=2cm, right=2cm, top=2cm]{geometry}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PACKAGES %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{minted}                     % Code
\usepackage{graphicx}                   % PNGs
\usepackage{algorithm}
\usepackage{algpseudocode}              % Algorithms
\usepackage{amsmath}                    % Rightarrow
\usepackage{hyperref}                   % Hyperlinks
\hypersetup{
    colorlinks,
    linkcolor=black
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagenumbering{gobble}

\title{\textbf{Final Project}}
\author{MacMillan, Kyle}
\date{December 11, 2018}


\begin{document}

\maketitle
\addcontentsline{toc}{section}{Title}

\newpage
\pagenumbering{roman}   % Set TOC page numbering to lowercase roman numerals
\tableofcontents
\addcontentsline{toc}{section}{Table of Contents}

\newpage
\listoffigures
\addcontentsline{toc}{section}{List of Figures}

\newpage
\pagenumbering{arabic}  % Set content page numbering to arabic numerals
% Setup Hyperlinks for the rest of the document
\hypersetup{
    colorlinks,
    citecolor=blue,
    filecolor=black,
    linkcolor=blue,
    urlcolor=blue
}

\section{Description of the program}
\setcounter{page}{1} % Set the page counter to 3
This write-up is for the 
\href{https://www.mcs.sdsmt.edu/ckarlsso/csc410/fall18/csc410_Final.pdf}{Final project} 
and the repository for my work is \href{https://github.com/macattackftw/HighPerfComputing/tree/master/final}{here}.
\\
This program was incredibly hard until I learned of \verb|std::next_permutation|
. Until then I had a ridiculous chain of nested for loops to iterate over up to 
$n = 10$. Also, because it was a nested loop I had to do a horizontal check to 
ensure there were not duplicate queens on a line. This made the program 
unbearably slow. Joe informed me of \verb|std::next_permutation| and it was a 
complete game changer. 

Armed with this new tool I began to design a solution capable of using it. After 
searching around online I found a 
\href{https://stackoverflow.com/a/7919887}{Stack Overflow post} that allowed me 
to calculate the $i^{th}$ permutation. Given $p$ processors and a known number 
of permutations given in the form of $n!$ I can calculate the number of 
permutations to send to each processor. This is not the \textit{best} load 
balance strategy, but it is not terrible. Since I am not pruning the 
permutations the only imbalance comes from transmitting that a valid board 
layout was found.

The graduate portion of this assignment allowed me to utilize a Task/Channel 
method (as described in Chapter 6) to complete the assignment. By having 
\verb|MPI_Send| and \verb|MPI_Recv| in the workers and master, respectively, I 
was able to meet that program requirement. Essentially the master goes directly 
into a receive loop, waiting for an \verb|MPI_Send| on the appropriate tag and 
source. Once receiving the value a counter is incremented and it checks if we 
have hit the expected number of solutions. If we have not finished it goes back 
into the receive loop, otherwise it sends out an \verb|MPI_Bcast| to all workers 
that changes a boolean flag from $false$ to $true$, which stops them from 
checking any more boards.

\subsection{Performance Analysis}
Timing was performed with the simple Linux \verb|time| command. This problem is 
not like our previous assignments. We have an exponential growth in the problem 
size \textit{at each step}. That means we don't really need high-fidelity timing 
to get a picture of what's going on. 



\section{Description of the algorithms and libraries used}
The STL's \verb|next_permutation| was a keystone in the design and execution of 
this program. Also used was \verb|MPI|, 

\section{Description of functions and program structure}

\section{How to compile and use the program}
This program can be compiled with the Makefile. Simply type: 
$$\texttt{make}$$
$$or$$
$$\texttt{make final}$$

\noindent To use the program type:
$$\verb|mpirun -np 129 .\final 13|$$

`129' represents the number of processors and `13' represents the $n$ part of 
the n-queens problem. 


\newpage
\section{Description of the testing and verification process}{\label{sec:test}}
Testing was done with printout verification and count verification. What that 
means is I bounced the printout arrays of n-queen positions and verified them by 
hand. This could obviously only be done on smaller $n$ values. For larger $n$ 
values I assumed the diagonal check was correct (since it was verified good at 
the lower level) and only verified with the count method. A function was made to 
test the count against a const array of known solution for a given $n$. 

\section{Description of what you have submitted}
Included in the submission is the code needed to compile the program, a Makefile 
to compile said code, and a detailed write-up of the assignment in pdf form.


\end{document}
